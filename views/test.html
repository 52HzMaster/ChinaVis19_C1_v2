<!DOCTYPE html>
<html>
<head>
    <!-- 移动相机的位置-->
    <meta charset="UTF-8">
    <title>test</title>
    <style type="text/css">
        body{
            background:white;
            margin: 0;
            padding: 0;
        }

        *,
        *:before,
        *:after {
            box-sizing: inherit;
        }

        #all_view{
            position: fixed;
            width: 100%;
            height: 100%;
        }

        #canvas-frame {
            border: none;
            cursor: pointer;
            background-color: #EEEEEE;
        }

    </style>
    <script src="/lib/jquery-3.1.1.min.js"></script>
    <script src="/lib/three.min.js"></script>
    <script src="/lib/OrbitControls.js"></script>
    <script src="/lib/tween.min.js"></script>
</head>

<body>
<div id="all_view">
    <div id="canvas-frame"></div>
</div>

<script>

    //===================================================== canvas
    let all_view = $("#all_view");
    let width = all_view.width();
    let height = all_view.height();

    let container = document.getElementById('canvas-frame');

    container.style.width = width + 'px';
    container.style.height = height + 'px';

    let renderer = new THREE.WebGLRenderer({antialiase:true});
    container.appendChild(renderer.domElement);
    renderer.setSize(width, height);
    renderer.setClearColor(0x151515, 1);

    //===================================================== camera
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(45, width / height, 1, 10000);

    //===================================================== resize
    window.addEventListener("resize", function() {
        let width = container.getBoundingClientRect().width;
        let height = container.getBoundingClientRect().height;
        renderer.setSize(width, height);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
    });

    //===================================================== camera
    let plane = new THREE.GridHelper(50, 50);
    plane.material.color = new THREE.Color("#62a6ff");
    scene.add(plane);

    //===================================================== controls
    let controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;
    controls.maxPolarAngle = Math.PI / 2.1;

    //===================================================== add Light
    let light = new THREE.DirectionalLight(0xefefff, 1.5);
    light.position.set(1, 1, 1).normalize();
    scene.add(light);

    //===================================================== add Line
    function initObject() {

        //轴辅助 （每一个轴的长度）
        let object = new THREE.AxesHelper(50);
        object.position.set(0, 0, 0);
        scene.add(object);

        let floor_material = new THREE.MeshBasicMaterial({color:"#FFF"});
        floor_material.transparent = true;
        floor_material.opacity = 0.3;

        //立方体 （x轴宽度，y轴高度，z轴深度，沿宽面分段数，沿高度面分段数，沿深度面分段数）
        let floor1 = new THREE.Mesh(new THREE.BoxGeometry(30, 5, 16), floor_material);
        //scene.add(floor1);
        let f1_edges = new THREE.BoxHelper(floor1, "#FFFFFF");//设置边框，可以旋转
        f1_edges.position.set(0,10,0);
        scene.add(f1_edges);

    }


    //===================================================== Circle path for the camera
/*    let segmentCount = 10;
    let radius = 20;
    let xyzArray = new Array(segmentCount)
        .fill(null)
        .map(
            (d, i) =>
                new THREE.Vector3(
                        /!*x*!/
                    Math.cos(i / segmentCount * Math.PI * 2) * radius,
                        /!*y*!/
                    5,
                        /!*z*!/
                    Math.sin(i / segmentCount * Math.PI * 2) * radius
                )
        );

    let curve = new THREE.CatmullRomCurve3(xyzArray);
    curve.closed = true;
    let g2 = new THREE.Geometry();
    g2.vertices = curve.getPoints(100);
    let m2 = new THREE.LineBasicMaterial({
        color: new THREE.Color("skyblue")
    });
    let curveObject = new THREE.Line(g2, m2);
    scene.add(curveObject);*/

    function zoom(x, y, z) {
        let from = {
            x: camera.position.x,
            y: camera.position.y,
            z: camera.position.z
        };
        let to = {
            x: x,
            y: y,
            z: z
        };
        let tween = new TWEEN.Tween(from)
            .to(to, 900)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onUpdate(function() {
                camera.position.set(this.x, this.y, this.z);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
            })
            .onComplete(function() {
                camera.lookAt(new THREE.Vector3(0, 0, 0));
            })
            .start();
    };

    //===================================================== animate

    //spline = curve;
    camPosIndex = 0;
    clock = new THREE.Clock();

    function animate() {

        initObject();
        TWEEN.update();


        renderer.render(scene, camera);
        requestAnimationFrame(animate);

    }

    animate();
    zoom(20, 20, 30);

</script>
</body>
</html>